1.哈希函数
三大特性
抗碰撞性：难以找到两个不同的输入，产生的哈希值是相同的；极小概率产生碰撞，但没有高效的方法人为创造，估计只能暴力破解
隐匿性：哈希值无法反推出原始输入数据的特性
Puzzle friendliness：原始输入数据难以推测哈希值；可以很方便的控制谜题难度，并且谜题一定是有解的；谜题很难被解决，但是很容易验证

常用分类
keccak256基于SHA-3标准，以太坊多场景使用
SHA256基于SHA-2标准，保证历史兼容


2.ECDSA椭圆曲线数字签名算法
优势：和RSA同级别安全特性下，密钥长度更短，计算效率更高；生成的签名较小，便于传输
R，S，V：R，S存储实际签名数据，V恢复公钥时使用
加密：公钥加密，私钥解密
加签：私钥加签，公钥验签
额外注释：签名中加入chainId信息，防止重放攻击


3.工作量证明PoW(Proof of Work)
挖矿原理
首先从节点交易池（TxPool）中获取交易，执行交易得到Block Header，
然后使用初始值2^256/difficult得到target，难度计算公式 当前区块难度 = 父区块难度 + (父区块难度 / 2048) * 调整系数 +难度炸弹补偿（可选）
再调用哈希函数计算Block Header和nonce得到hash值，
最后比较hash值是否小于等于target，是则将nonce写到Block Header中，发布；否则nonce++，重复以上步骤

矿工收益
gasfee：设置启动参数miner.etherbase，打包时读取为coinbase，执行交易时以gasfee给coinbase发放奖励
固定基础奖励：2015年5ETH，2017年3ETH，2019年2ETH
叔块奖励：主链的叔叔区块（孙辈没有奖励）被打包的时候，距离普通块的长度，叔叔区块2/8~7/8倍出块奖励；普通块包含叔叔区块会获取数量*1/32倍出块奖励,数量最大为2


4.权益证明
验证者：质押 32 个 ETH 到质押合约（Deposit Contract），运行三个服务：执行层客户端(EL, Execution Layer)、共识层客户端(CL, Consensus Layer)、验证者客户端(Validator)
提议者和见证者：验证者在Slot中的一种身份，且只能在一个Slot中，提议者负责打包区块，广播，见证者负责接收广播，投票
Slot和Epoch：每 12 秒为一个 Slot，前4秒提议者打包区块，广播给区块委员会中的其它见证者；见证者接收到新区块后进行投票；最后4秒委员会成员广播投票结果，并发送给下一个Slot的提议者
Epoch：32个Slot为1个Epoch，代表一个完整回合，是网络进行验证者洗牌、奖励结算的基本单位

交易过程
用户发送交易--执行层节点接收交易，验证有效性--交易有效保存到mempool， 通过gossip 网络发送给其它执行层节点--其它执行层节点接收到广播，保存到mempool--
当前Slot随机产生提议者，提议者向本地共识层节点发起生成区块请求--本地共识层节点通知本地执行层节点生成PayloadId，返回给提议者--提议者广播给其它共识层节点，其它共识层接收通知其执行层节点--
其执行层节点执行交易，验证有效性，投票通过后保存到本地数据库--交易经过两个检查点（相当于两个完整的Epoch）后，状态变成 finalized，检查点为Epoch的第一个Slot

验证者的余额：实际余额，验证者实际持有资产的数值，包含存到质押合约的金额、奖励、惩罚；有效余额，有实际余额衍生，每Epoch变化一次，无小数，最多32ETH
奖励的途径：验证区块；提议区块，每个slot只有1个，比较稀少；同步委员会奖励，每256个Epoch选出512位验证者，时间跨度比较大
奖励接收：奖励记录在Beacon链上，提议新区块时，会创建长度为16的体现请求队列，根据协议规则判断是否有合格的提款，有就加入队列，下次提议新区块时继续以上步骤；因为每个区块只能创建长度为16的队列，故奖励体现比较慢
惩罚：认证者，证明缺失，迟交，不正确；同步委员会成员没有参与签署；提议者没有惩罚
额外注释：退出时和奖励提现时，都是共识层客户端通知执行层客户端生成区块时使用withdrawals字段传递信息，故不消耗gas费


5.Merkle树和MPT树（待后期完善）
Merkle树
概念：哈希树，特殊的二叉树结构，叶子节点保存实际数据或者实际数据的hash值，非叶子节点包含其子节点的hash值
作用：高效的验证数据的完整性和一致性
计算过程：叶子节点进行hash，非叶子节点拼接两子节点hash再进行hash，最终生成root节点；当节点数为奇数时，复制最后一个节点的hash值
验证：轻节点向全节点发起请求获取叶子节点的数据、位置、默克尔路径、根哈希数据，再进行hash计算出结果与根hash比较
缺点：
依赖节点数量为偶数；
保持树的平衡性，以确保验证路径的长度最短；
动态更新效率低，交易树固化无影响，但状态树是动态更新的；
依赖位置，主要体现在可用性上，例如恶意更改了全节点交易信息的位置，数据是正确的，但轻节点验证不通过；
哈希碰撞；
全节点如果伪造默克尔树的非根节点的hash（知道父节点，伪造出子节点的hash是比较容易的，输入和输出数量的问题），轻节点无法判断

MPT树
概念：Merkle树和Patricia树的结合体
用途：状态树、交易树、收据树
优点：
不需要理会树的平衡性，并且以key为路径，维护相对简单
不需要为每个不同的key创建单独的节点，而是根据key的路径合并与分叉，非叶子节点的压缩比更大
极端情况下查找的层级会比传统默克尔树更深，但是加载节点的范围更小
节点介绍：
shortNode：Key存储压缩路径，Val可为fullNode、shortNode、hashNode、ValueNode
shortNode struct {
       Key   []byte
       Val   node
       flags nodeFlag
}
fullNode：Children包含一个长度为 17 的节点数组，前 16 个位置存放子节点指针，最后一个位置保存可选的关联值
fullNode struct {
       Children [17]node // Actual trie node data to encode/decode (needs custom encoder)
       flags    nodeFlag
}
hashNode：表示节点的hash值，存储于数据库，使用时利用hash从数据库加载
hashNode  []byte
valueNode：对应默克尔树的叶子节点，被shortNode或fullNode引用，本身不能作为单独的节点
valueNode []byte
插入：


6.P2P网络 （待后期完善）







