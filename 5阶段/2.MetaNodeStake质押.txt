1.继承合约介绍
Initializable，实现initialize函数替代constructor函数，避免状态污染，constructor函数在实现合约部署时执行，并且修改的是实现合约的状态变量，modifier initializer修饰限定只执行一次
UUPSUpgradeable，升级合约使用uups代理，实现_authorizeUpgrade函数，控制升级权限
PausableUpgradeable，增加_paused开关，开关是否关闭决定合约中重要操作是否能正常进行，核心是modifier whenNotPaused
AccessControlUpgradeable，权限控制，_grantRole函数设置角色，_revokeRole函数取消角色，配合modifier onlyRole验证角色


2.核心结构体
Pool：记录每个质押池子信息
UnstakeRequest：提取质押代币请求
User：记录用户信息


3.核心状态变量
MetaNode：质押代币所发放的token地址
startBlock和endBlock：质押合约的时间周期
MetaNodePerBlock：每个区块token奖励数
withdrawPaused：提取开关
claimPaused：认领开关
totalPoolWeight：总权重
pool：池子数组，依次记录池子信息
user：用户映射，根据池子分组，记录参与质押用户信息


4.核心难点函数（其中计算的误区通常是比例换算，accMetaNodePerST可以看做是质押代币对应token的价格，后者表示前者价格时需带上精度，例如1ETH=10^18token）
initialize：初始化合约权限、角色、token地址、每个块所获奖励、开始区块、结束区块等信息
addPool：创建池子信息
updatePool：更新池子的奖励，第一步，(当前区块号-池子最后奖励区块号)*每个区块token奖励数*池子权重，第二步，结果/总权重，第三步，结果*1ether，第四步，结果/池子质押代币数，第五步，结果+池子每单位质押代币数所占token
pendingMetaNode：查询当前可取token数量，合约层面奖励->池子层面奖励->质押代币层面奖励
withdrawAmount：获取用户请求中的到期质押代币金额和请求中的总质押代币金额
deposit：存款，设置pendingMetaNode，设置finishedMetaNode
unstake：赎回请求，有等待期，设置pendingMetaNode，增加requests，设置finishedMetaNode
withdraw：赎回已过等待期代币
claim：获取token奖励


5.整体逻辑梳理
合约初始化，设定角色权限等合约维度信息；
增加池子，设定池子维度信息；
更新池子，更新池子单位代币的奖励数和最后设定奖励区块号，注意：单位代币的奖励数是当前单位代币奖励数+合约维度每个区块token奖励数*区块数*池子占合约权重比例；
存款时，更新池子信息，计算并覆盖当前可提取奖励数量，然后增加存款金额，利用增加后的存款金额计算出的奖励数量覆盖已完成奖励数量；
赎回时，更新池子信息，计算并覆盖当前可提取奖励数量，然后减少存款金额，利用减少后的存款金额计算出的奖励数量覆盖已完成奖励数量，最后增加赎回请求，请求的具体时间由当前区块+池子维度的锁定区块数决定；
提取代币时，遍历赎回时生成的请求，过滤出已到期的，进行质押代币的转账，然后对请求数组进行移位（将下标从后面移到前面，删除后面）；
提取奖励时，更新池子信息，计算可提取奖励数量=当前单位代币奖励数*当前质押代币数-当前已完成的奖励数+当前可提取数量奖励数，设置可提取奖励数量为0，利用存款金额计算出的奖励数量覆盖已完成奖励数量，奖励转账；





